---

# 20_05_18_자바

---

## 복습

### 생성자

super , this

### 추상클래스

추상메소드를 가지고 있는 클래스

선언부는 가지고 있지만 사용부는 없는

사용하려면 재정의

추상 클래스 상속받은 자식클래스가 

추상 클래스의 메소드를 자식클래스가 재정의 해서 구현 같은 이름으로 메소드 사용 표준 만듦

### 형변환 

기본 형변환

크기를 기준으로

묵시적 : 크기가 작은 자료 형이 큰 자료형으로 변환 묵시적

명시적 : 큰거 -> 작은거 명시적

객체 형변환의 기본 조건은 데입연산자 기준으로 = 다름

상속을 기준으로

묵시적 : 우변항이 자식 좌변항이 부모 자식의 클래스가 부모의 클래스를 오버라이딩하면 부모 메소드가 아닌 오버라이딩된 메소드를 사용

명시적: 우변항은 부모 좌변항 자식 메모리는 자식이 더 큼 - 전제 조건 부모가 자식의 참조변수가 ....

### 예외처리

프로그램 실행시 예기치 않은 문제점으로 인해서 소프트 웨어가 종료

문제 발생하더라고 소프트 웨어가 종료되지 않고 진행되려고

1 컴파일시점

2 런타임시점

잡아주기 위해

1직접 try catch finaly

2간접 throws

3사용자정의 throw

### static

붙히는곳 : 멤버변수이거나 메소드

로딩시점 

static : 인스턴스 객체 만드는 순간

nonstatic : 객체 생성시

메모리 시점 

static:클래스당 하나씩

nonstatic : 인스턴스 객체당 메모리 할당

static메소드 안에서는 nonstatic 메소드 , 변수 호출 x

nonstatic메소드 안에서는 static메소드, 변수 호출 가능

은닉성

### 접근제한자

public 모든 접근 가능

protected 자신의 패키지 내에서는 사용 단 상속 관계는 사용가능

dafault 자신의 패키지 내에서만

private 자신의 클래스에서만 접근

### 인터 페이스

기능들의 확장을 위해서

상속은 클래스 -클래스 - 단일상속만 지원 1클래스 1슈퍼클래스 

여러 기능을 상속 받아서 사용하기 위해 - 동일한 이름의 기능 필요

상수변수와 추상 메소드를 가지고 있는 형태

기본적으로 멤버변수 만들면 public static final

기본적으로 메소드 만들면 public abstract

인스턴스 객체 만들수 없고 자식 클래스 이용해서만 만들고 

묵시적 형변환으로 다용성

이름에 able이 들어가는 경우가 많음 ~를 가능하게 한다 - throwable은 아님

### 제너릭

컴파일 시점에 타입을 만드는 것이 아니라

컴파일 시점과 런타임 시점에 같이 만듦?

 컴파일 시점에 리턴 타입인

<T> <?> <T extends>

### 컬랙션

자료구조들을 일반화 시킨 집합

자료구조 : 같은 타입의 데이터를 효율적으로 저장 탐색하기 위해 

우리가 말하는 컬랙션은 거의 인터페이스 - 리스트 셋 큐 스택 - 맵은 컬랙션과 조금 다름

자바에서 스택은 잘 않씀

### String

스트링  클래스는  java.lang 임포트 하지 않아도 사용

jvm이 자동으로 로딩 시킴-문자열 , 시스템 

스트링 - 한 번 만들면 절대 변하지 않음 - 동기화

스트링 버퍼,빌더 - 변하는 클래스 + 같은 연산이 많으면 버퍼,빌더 사용 - 비동기화 - 웹

### JAR

자바 압출 파일 자르 - 웹은 WAR 

### 메소드



### 클래스

눈에 보이는 사물을 추상화 하는 기본적 단위

객체의 속성 - 맴버변수 객체의  움직임 - 메소드

 접근제한자4개 , 활용제한자4개 스테틱 앱스트랙트, 파이널 싱크로나이즈드

디폴트 반환형 메소드명 매개변수 + 접근제한자2가지 퍼블릭 디폴트 , 홣용제한자 2가지 파이널 앱스트랙트

파이널은 맴버-상수, 메소드-오버리이딩금지 클래스-상속금지

### 오버 로딩

같은 클래스에서 메소드 명 동일하지만 변수나 이런거 다름

같은 이름의 함수를 여러 개 정의하고, 매개변수의 유형과 개수를 다르게 하여 다양한 유형의 호출에 응답하게 한다.

### 오버 라이딩

상위 클래스가 가지고 있는 멤버변수가 하위 클래스로 상속되는 것처럼 상위 클래스가 가지고 있는 메소드도 하위 클래스로 상속되어 하위 클래스에서 사용할 수 있다. 하지만, 하위 클래스에서 메소드를 재정의해서 사용할 수 있다.

상속 관계에 있는 클래스 간에 같은 이름의 메소드를 정의하는 기술을 오버라이딩(Overriding) 이라고 한다.

### 배열

연속적인 공간에 같은 타입의 데이터를 모아둔 것

length 실제 2차원배열 어떻게 그려지는가 -> 메모리 구조 스택, 힙, 메소드 에어리어

new에 의해 만든것은 힙에 / 일반 변수에 의한 것은 

---

## 오늘 수업 - 자료구조 책을 보아라

---

### stack 후입선출 lifo

데이터와 데이터 사이에 빈공간 없게 하려고 삭제 할 떄도 뒤에서 부터

redo undo / 크롬에서 뒤로가기 앞으로가기 / 백업,복원의 시점 로그 파일 이벤트 뷰어

오버플로우 관련 

값 입력할때 쓰는 메소드 push 

값 삭제할때 쓰는 메소드 pop

스택 두개를 붙혀서 테크 형태로

### queue 선입선출 fifo

데이터와 데이터 사이에 빈공간 없애고 싶음 

메세지 큐 실제 컴퓨터에서 제일 많이 사용

값 입력할때 쓰는 메소드 put top?

값 삭제할때 쓰는 메소드 get front rear

원형 큐

### overflow / underflow

넘치게 되는 경우 = overlfow

비었는데 삭제 - underflow

### tree

이진탐색트리

biuary tree 

b tree - Entry Sequenced File

Entry sequenced file은 레코드가 입력되는 순서대로 저장되는 파일이다. 레코드가 입력되는 순서대로 파일에 저장되기 때문에 파일에 저장된 레코드들은 정렬되어있지 않다. 파일에 저장된 레코드들이 정렬되어있지 않기 때문에 어떤 레코드를 찾기 위해서는 파일의 앞쪽부터 순차적으로 레코드를 읽어야한다. Entry sequenced file은 데이터를 관리한다는 측면에서는 매우 비효율적인 구조이다. Entry sequenced file의 이러한 문제점을 해결하기 위해 레코드가 입력될 때마다 레코드들을 정렬하는 sorted file을 생각할 수 있지만, sorted file에는 아래와 같은 치명적인 문제점이 존재한다.

B+ 트리(Quaternary Tree) - Indexed Sequential File

B 트리에서 사용되는 entry sequenced file과 반대되는 것으로 indexed sequential file이 있다. Indexed sequential file은 인덱스를 통해 데이터 파일의 각 레코드에 접근할 수 있으며, 데이터 파일의 레코드가 정렬된 순서로 저장되어 있는 구조를 갖고 있다. Indexed sequential file은 인덱스를 통해 각 레코드에 접근할 수 있다는 점이 entry sequenced file과 같지만, 데이터 파일의 레코드가 정렬되어 있다는 점이 다르다. 

### grape



```java

```





